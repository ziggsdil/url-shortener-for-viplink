# Url-shortener application


## Описание и технические требования

На лекции мы проследили за процессом, как разрабатывать новые крутые продуктовые фичи в нашем сервисе Такси. Давайте реализуем что-то похожее на небольшом проекте `UrlShortener`. Он всего лишь умеет укорачивать урлы и дает немного управления над созданными редиректами (можно посмотреть статистику использования и удалить ссылку).

Представьте, что нам необходимо вывести наш сервис `UrlShortener` на новый качественный уровень на рынке подобных систем. Надо завоевать долю на рынке и нарастить количество активных пользователей с X до Y %. Это стратегическая цель. Но как ее достичь?

Дальше задание разделяется на 2 пути: вы можете взять описанную ниже фичу либо придумать свою крутую. Главное — реализовать в коде и показать путь фичи от идеи до воплощения. Если пойдете по второму пути, то все равно нужно реализовать в коде предложенную фичу, чтобы наши автотесты проверили ваш код.

В требованиях к заданию есть творческая составляющая — нужно будет написать отчет в формате md. Если идете путем своей фичи - описываете в этой части свою фичу, если нет — то нашу. Подробности ниже.

### Давайте сначала присмотримся к фиче, предложенной нами

Кто-то проанализировал рынок за вас и решил, что киллер-фичей, которую так необходимо реализовать во что бы то ни стало, является "VIP ссылки"!

Что это? Всё просто. Вы помните, что `UrlShortener` возвращает произвольную комбинацию символов в укороченном URL. А в VIP ссылках это не так: пользователь сам указывает, какой будет его короткая ссылка, конечно, только если заданная им комбинация символов свободна.

Формальное описание интерфейса на OpenAPI 3.0 тут [openapi.yaml](openapi.yaml)

А ниже для общего представления неформальное описание.

make_shorter на входе получает:
```
long_url = "user-defined-long-url"
optional vip_key = "user-defined-symbols"
optional ttl = 1
optional ttl_unit = SECONDS, MINUTES, HOURS, DAYS
```

Максимальный TimeToLive не должен превышать 2 дней (иначе красивые vip ссылки закончатся).

В ответ на операцию приходит
```
short_url = "example.com/xyz" - короткая ссылка
secret_key - ключ для управления ссылкой
```

Ну или ошибка 400, если есть какие-то проблемы с входными параметрами, например, если vip_key уже занят или переданы невалидные значения для TTL.

### А что если у меня своя классная идея?
Все просто - опиши ее и реализуй, а потом презентуй в коротком (до 2 минут) видео ролике - загрузи видео на любой открытый видеохостинг - ютуб, например. В ролике необходимо показать функциональность твоей фичи. Не забудь реализовать базовую фичу "vip ссылки", она будет проверена автоматически.

### Требования к результату домашней работы

0. Форкнуть (fork) данный репозиторий с заданием в свой репозиторий;
1. Необходимо описать идею (vip ссылки или свою) в 1-2 предложениях;
2. Сформулировать продуктовые гипотезы - 1-2 штуки в формате, как было на лекции;
3. Оценить примерные трудозатраты (попробуй аргументировать оценку, например, требуемым количеством новых классов, объемом кода);
4. Придумать, можно ли сделать MVP, если да, то как он будет выглядеть и сколько это займет времени;
5. Проработать архитектуру и описать ее в тексте (в качестве формального описания подойдут openapi описание, диаграммы классов, компонентные диаграммы - в зависимости от того, что лучше отразит суть изменений и, что по вашему мнению будет понятнее проверяющему);
6. Реализовать полное решение идеи в коде. Если пошли по пути разработки своей супер-идеи, то не забудьте реализовать vip ссылки;
7. Добиться чтобы все предоставленные в исходном репозитории тесты на vip ссылки проходили успешно, внося правки в код сервиса, а не тестов :) ;
8. Придумать AB-тест - какие выборки пользователей будут в эксперименте? Какие параметры фичи будем проверять в каждой выборке?
9. Выбрать и описать набор наблюдаемых продуктовых метрик, по которым можно сделать вывод, что фича "взлетела". Какие значения метрик ожидаем увидеть?
10. Сделать отчет в файле README.md (имеющийся удалить, свой добавить) в своем репозитории с ответами на эти вопросы.

Если идешь путем разработки своей фичи, то отчет пиши про неё. Если реализуешь только vip ссылки, то отчет по ней.

Если что-то непонятно, смело задавай вопросы своему ментору.

## Работа с приложением

Всё что можно делать с приложением — можно делать с помощью make. Для этого нужно перейти в директорию `deploy` и 
следовать инструкциям ниже:

### Требования

Необходимо, чтобы были установлены следующие компоненты:

- `docker` и `docker-compose`
- `go 1.19`
- `make`
- `golangci-lint`

### Запуск

0. Создать `.env` файл с этими переменными (можно командой `make env`). Для локального поднятия сервера также можно
использовать конфиг `deploy/default.yaml` (дополнив его). Но для локальных тестов всё равно придётся сделать env.
```dotenv
POSTGRES_DB=...
POSTGRES_USER=...
POSTGRES_PASSWORD=...
POSTGRES_HOST=...
POSTGRES_PORT=5432
```

2. Создание базы в docker-контейнере (чтобы не работать с локальной базой):
```commandline
make db
```

3. Запуск приложения:
```commandline
make run
```

### Тестирование

- Запуск тестов (внимание! тесты поднимают заново базу в Docker-контейнере, старые данные теряются):
```commandline
make test
```

### Статический анализ

- Запуск линтеров
```commandline
make lint
```

- Запуск форматирования кода
```commandline
make format
```

### Дополнительные команды

- Открытие консоли базы данных внутри Docker-контейнера:
```commandline
make open_db
```

- Почистить базу внутри Docker-контейнера (данные + схема):
```commandline
make clean_db
```

- Вывести список всех команд и их описание:
```commandline
make help
```